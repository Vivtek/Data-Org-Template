=pod

=encoding utf8

=head1 NAME

Data::Org::Template::Cookbook - Simple recipes for my flavor of templates

=head1 DESCRIPTION

I have no memory whatsoever for syntactic detail, which is a significant handicap for a programmer. As a result, I rely on cookbooks, notes, and code snippets to
do the most trivial of things - I can only whip out code quickly when it's entirely non-trivial, like tossing closures around.

This set of examples is therefore really more for my own use than yours, but I hope you find it useful as well.

=head1 BASIC TEMPLATING

=head2 Hello, world

The most fundamental programming task, as we all know, is to greet the entire human race. Here's how you'd do that using a DOTemplate - and of course by changing the
input data you can greet anybody you like.

    use Data::Org::Template;

    my $t = Data::Org::Template->new ("Hello, [[name]]!");
    print $t->text({name => 'world'});

So far, this is no different from any other template engine - we have a field delimited by some kind of special brackets, and the field names a data item in a hashref.
This is just how you set it all up.

=head2 Multiline templates

What I normally do for multiline templates (which is the majority of templates) is this:

    use Data::Org::Template;

    my $t = Data::Org::Template->new (<<'EOF');
    Hello to:
    [[name]]
    EOF
    
    print $t->text({name => 'world'});

=head2 I don't like those [[brackets]]

You can also easily use a different type of bracket.

    use Data::Org::Template;

    my $t = Data::Org::Template->new ("Hello, {name}!", '{}');
    print $t->text({name => 'world'});

=head1 DATA GETTING

So far we've just passed a single hashref to the template when we express it, but we can get fancier than that.

=head2 Register a data getter

You can register a data getter ahead of time so text retrieval will always produce an updated value.

    use Data::Org::Template;

    my $data = {name => 'world'};

    my $t = Data::Org::Template->new ("Hello, {name}!", '{}');
    $t->data_getter ($data);
    
    print $t->text; # --> Hello, world!
    
    $data->{name} = 'Bob';
    print $t->text; # --> Hello, Bob!

=head2 Getting data from multiple sources

All the getters we've used so far have had a single source - one hashref holding values. But in reality, a getter can accept a list of sources.
The getter will consult each source in turn until it gets a defined value.

    use Data::Org::Template;

    my $t = Data::Org::Template->new ("First [[x]] then [[y]]");
    my $data = {x => 'xval'};
    $t->data_getter($data, {y=>'yval'});
    
    print $t->text; # --> First xval then yval
    
    $data->{yval} = 'not yval';
    print $t->text; # --> First xval then not yval

Notice that the value for C<y> in the first hash now shadows the value in the second hash.

=head2 Special cases in multiple-source retrieval

There are two special cases that can come in handy. The first is that if there is a "source" in the list that is a scalar value, then it can be retrieved with the
special field name of "." - a period.

    use Data::Org::Template;

    my $t = Data::Org::Template->new ("Value: [[.]]");
    
    print $t->text ('value'); # --> Value: value
    
The second comes into play when a data source list is passed to a template that already has a registered data getter. The getter is only consulted for values if
the special source "*" has been included in the list passed to expression. That explanation isn't all that clear, but the code probably makes it obvious:

    use Data::Org::Template;

    my $t = Data::Org::Template->new ("First [[x]] then [[y]]");
    my $data = {x => 'xval'};
    $t->data_getter($data);
    
    print $t->text ({y => 'yval'});      # --> First  then yval
    print $t->text ({y => 'yval'}, '*'); # --> First xval then yval
    print $t->text ({y => 'yval', x => 'not xval'}, '*'); # --> First not xval then yval
    print $t->text ('*', {y => 'yval', x => 'not xval'}); # --> First xval then yval
    
The sources are still consulted in the order they're provided, so in the final print statement the template's own getter returns a value for C<x> before the value
passed in for expression.

=head2 Magic values

Any value returned by a data getter can also be a coderef (a closure) - if so, it is executed to get the final value. (If the return value is still a coderef, it
will be executed again. And again. Try not to shoot yourself in the foot with a self-returning coderef, obviously.) This is a kind of neat way to embed a template
in another template - just make the embedded template's expression a magic value in the data for the second template.

    use Data::Org::Template;

    my $data = {name => 'world'};
    $t = Data::Org::Template->new("Hello, [[name]]!");
    $t->data_getter ($data);

    my $t2 = Data::Org::Template->new ("Current greeting: '[[greeting]]'");
    $t2->data_getter ({greeting => sub { $t->text }});

    print $t2->text();  # --> Current greeting: 'Hello, world!'
    $data->{name} = 'Bob';
    print $t2->text();  # --> Current greeting: 'Hello, Bob!'

Personally, I think that's pretty darn cool.

=head2 Indentation preservation

One feature I actually wrote this library to provide is preservation of indentation when multi-lined values are inserted into a template.

    use Data::Org::Template;

    my $text = <<'EOF';
    This is a text
    that consists
    of multiple lines.
    EOF
    
    my $t = Data::Org::Template->new (<<'EOF');
    This is the value: [[text]]
    And this is the line after it.
    EOF
    
    print $t->text({text => $text});
    # This is the value: This is a text
    #                    that consists
    #                    of multiple lines.
    # And this is the line after it.
    
My original impetus for this idea was years ago, when I was dabbling with literate programming and realized that it I<didn't work> for Python because it was
such a pain to insert values that needed their indentation preserved properly.


    

=format comment

 Other things to put in a cookbook:
 - Retrieving values with a formatter
 - Registering your own formatter

 - Building templates directly (handing it the token stream)

 - Conditionals
 - "With" for hashrefs within hashrefs

 - List templates
 - Specific Iterator::Records expression

 - Reading the template as a stream
 - Adding your own transducers

